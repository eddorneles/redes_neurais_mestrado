
%%Modos de funcionamento da rede;
% rdm = 1 inicializa os pesos, centros e dados de entrada.
% desativar após rodar o codigo pela primeira vez
%caso faça alguma alteração no numero de neuronios, reativar o random, para
%reinicializar os pesos, centros etc
%%treino1 é a primeira parte do treino
%onde são ajustados os centros e raios. 
%após ter resultados satisfatorios, desative para congelar os raios e
%centros
%%treino 2 controla a parte do ajuste de pesos, no projeto da camada de
%%saida.

%%caso deseje entrar em modo de treino, basta settar treino1 e treino2 como
%%0, logo irá automaticamente passar pra fase de teste.
rdm = 1;
treino1=1;
treino2=1;





TAM = 1000;
%%WTA
%%Números de centros
C = 10;
O = 1;
%%tx de aprendizado
eta = 0.0001;



erro = (0.01)/2;
ger = 1000;
%iter = 0;



if(treino1==1)
    
    %% inicializaçao dos valores
    if(rdm == 1)
        eucl = [];
        WTA = [];


        Ci = rand(C,2)-0.5;
        W = rand(O,C);
        
        

        %dados_br = [0.52,2.31,0.96,0.94,0.35,1.76,0.33,3.88,0.23,1.24,0.52,1.76,0.13,3.07,1.66,5.06,0.88,2.44,0.9,3.45,0.81,0.06,0.14,2.57,1.17,2.11,4.7,0.34,1.55,1.98,1.5,5.82,1.08,2.02,1.2,1.87,0.39,0.69,1.33,4.43,1.26,1.83,4.25,1.66,0.87,1.02,0.39,3.78,1.04,1.35,4.2,4.5,0.76,2.22,3.87,6.04,1.24,2.79,0.33,3.44,0.95,1.85,3.0,5.01,0.84,0.17,3.08,0.52,0.3,2.44,0.8,4.47,0.47,3.02,1.82,3.22,1.21,0.68,3.35,1.25,1.25,0.98,4.14,2.61,0.62,1.07,2.38,3.92,1.53,1.16,2.4,1.19,0.48,1.05,3.7,1.87,0.64,0.21,1.53,4.37,0.57,1.6,1.85,2.31,1.3,2.39,0.81,1.63,0.62,2.31,3.43,0.77,1.54,0.67,4.59,4.51,0.18,0.2,3.31,0.88,1.51,1.67,3.13,2.23,0.42,1.44,1.98,5.52,0.18,2.83,3.1,3.86,1.53,2.26,2.84,2.46,0.95,1.54,2.77,1.78,1.51,2.68,2.49,5.23,1.3,2.49,3.5,5.63,1.08,2.35,1.74,4.89,0.43,3.03,3.71,3.7,0.72,1.38,1.09,0.57,0.32,0.46,1.21,2.43,1.47,1.35,4.1,5.22,1.47,1.3,3.29,4.35,1.19,3.14,1.73,0.13,1.37,0.03,1.52,2.13,0.79,2.6,1.68,1.04,1.47,1.85,2.28,2.65,0.98,2.07,0.06,6.15,0.51,0.6,4.39,3.21,1.51,0.74,2.05,3.31,0.26,3.08,2.75,4.02,1.47,1.27,0.36,4.64,0.64,0.25,3.26,5.21,1.2,0.09,3.71,4.28,1.42,2.66,3.43,3.44,0.62,0.5,3.84,0.94,0.78,0.55,3.76,3.09,0.14,0.18,3.11,1.14,0.84,0.47,4.21,1.05,1.15,2.88,1.41,2.69,1.18,0.9,4.44,3.45,1.48,1.34,1.58,5.83,0.7,0.6,4.26,3.22,0.07,2.49,1.32,1.28,0.13,2.99,3.09,6.14,1.03,0.89,4.66,3.0,1.02,0.95,3.75,4.63,0.52,2.51,0.69,5.58,0.25,0.79,3.75,1.84,0.56,1.43,2.34,3.32,1.49,1.3,0.29,2.8,1.08,2.38,3.14,2.82,0.53,1.03,1.6,2.57,1.31,2.47,3.76,5.47,0.03,2.33,1.35,4.52,0.71,2.31,3.91,3.23,0.41,1.08,3.92,1.81,0.53,1.29,1.36,1.12,0.0,0.49,0.36,1.82,0.24,0.41,3.67,4.73,0.05,0.66,2.11,3.93,1.16,1.13,3.23,4.48,0.76,1.05,3.87,0.58,0.59,0.51,2.14,3.91,0.51,0.83,1.54,5.46,1.25,1.88,2.74,3.07,0.06,0.99,4.55,0.01,1.36,1.28,1.02,2.09,1.41,0.37,3.96,3.11,0.6,0.28,0.04,3.08,1.23,0.7,1.45,2.02,0.31,2.44,1.27,4.5,0.63,2.24,2.18,0.52,1.3,2.53,2.68,5.0,0.66,1.88,2.59,4.38,1.08,1.01,1.67,5.74,0.31,2.56,4.62,2.15,1.41,2.41,4.27,3.64,0.9,0.13,2.7,1.32,0.0,2.84,1.11,5.58,1.37,1.91,3.96,3.97,0.34,2.75,4.52,1.08,1.46,2.76,2.9,0.98,1.06,2.65,3.34,1.81,0.26,2.61,4.27,0.32,1.55,2.81,1.88,0.5,0.99,1.19,2.87,2.61,0.04,3.08,2.64,4.46,0.51,0.02,0.02,4.5,0.63,1.92,0.79,1.46,0.16,2.91,3.53,1.14,1.05,2.2,1.68,2.89,1.24,1.88,2.41,1.58,0.76,1.4,0.49,0.24,1.48,2.86,1.32,4.06,1.47,0.1,0.21,5.55,1.13,2.37,0.82,3.21,1.13,0.14,0.25,2.12,1.24,0.04,2.26,0.22,0.85,1.29,3.25,3.72,1.09,0.83,0.09,0.04,0.48,1.09,3.19,2.68,0.48,2.44,4.62,2.09,0.74,3.14,1.17,5.78,1.24,1.27,3.82,0.54,1.14,2.11,0.32,5.76,0.94,1.08,0.01,1.84,0.03,1.77,1.12,4.29,1.36,2.69,1.51,3.75,0.5,1.96,0.46,2.8,0.67,1.8,2.43,5.16,0.92,3.06,4.02,4.91,0.77,1.06,1.59,3.81,1.26,1.45,2.79,4.99,1.22,1.44,3.92,1.91,0.15,0.29,0.68,0.07,1.26,1.35,1.38,4.27,1.39,2.88,3.88,2.8,1.34,0.57,2.42,4.96,0.0,2.05,2.92,4.74,0.11,3.09,2.45,1.8,0.56,3.12,4.5,1.44,0.35,0.38,1.84,4.87,1.39,1.56,0.97,5.45,1.09,2.09,2.84,5.87,1.06,2.07,2.07,2.73,0.11,0.5,1.84,4.5,0.31,1.95,4.24,5.25,0.69,1.99,1.13,3.79,1.3,2.48,0.62,4.79,1.11,2.32,0.87,2.01,1.1,1.86,0.74,0.92,0.08,1.66,2.03,3.01,1.56,1.53,1.31,1.46,0.54,2.12,3.98,5.58,0.13,0.52,3.94,6.16,0.76,0.98,4.34,3.73,0.17,2.13,0.41,5.16,1.51,1.07,1.33,1.27,0.6,1.92,1.25,5.72,0.07,1.88,4.67,5.15,0.36,2.87,1.11,0.33,0.82,2.45,2.44,2.63,0.66,1.29,2.04,0.92,0.26,1.66,0.62,1.02,1.42,1.78,1.17,2.77,0.43,0.38,3.79,3.0,1.4,0.01,3.19,5.19,0.33,3.1,1.32,2.28,1.2,1.48,3.56,1.09,1.44,0.9,4.44,1.54,0.15,1.19,4.46,0.55,0.46,2.69,4.67,2.13,0.3,2.91,4.19,1.01,0.02,2.89,4.15,1.24,0.51,0.5,0.63,0.47,1.06,2.09,1.8,3.17,1.02,2.09,1.24,1.04,1.3,0.73,2.15,2.0,1.08,1.22,3.53,3.72,0.92,2.92,1.72,2.54,0.53,0.73,1.88,2.6,0.29,0.59,1.92,4.85,0.47,2.04,4.41,0.8,0.61,0.03,2.67,2.19,0.72,3.1,4.05,0.25,0.07,2.43,3.11,2.68,1.4,1.3,2.06,2.21,0.28,1.52,0.16,2.58,0.7,2.17,0.69,0.13,0.94,0.16,4.01,1.85,0.44,1.27,0.77,4.74,0.31,1.0,1.77,1.48,0.54,2.25,3.8,5.27,0.97,2.09,2.8,5.35,0.4,1.42,2.32,3.83,0.22,1.73,3.66,3.53,0.66,3.14,4.17,0.09,0.07,1.78,4.41,1.53,1.4,0.24,3.64,3.29,0.2,0.51,3.79,0.1,0.64,2.91,0.73,5.88,0.68,3.02,2.14,6.17,0.75,1.63,2.13,2.49,1.15,1.34,0.93,0.1,0.9,0.71,2.89,2.75,1.48,2.66,0.7,4.37,0.68,2.53,2.81,1.53,1.56,2.73,0.99,2.32,0.57,2.47,2.44,1.7,1.53,2.32,1.93,5.13,1.39,2.0,3.79,0.83,1.38,0.27,2.07,0.65,0.98,0.06,1.26,1.53,0.94,0.06,4.08,6.0,1.31,1.92,4.23,2.15,1.36,0.27,2.77,3.49,1.37,0.56,3.97,1.9,0.67,1.09,3.07,2.71,0.41,2.51,0.04,1.88,1.57,2.28,0.4,2.75,1.55,0.03,4.59,2.52,1.42,2.33,2.51,6.2,1.38,0.09,0.03,1.22,0.76,2.26,4.48,3.83,1.13,0.58,1.87,6.01,0.15,0.48,0.59,3.48,1.49,1.64,4.25,5.11,0.7,2.93,1.27,2.21,0.91,0.24,1.07,1.24,0.01,0.59,0.9,5.26,0.58,1.38,2.18,2.3,1.28,2.34,0.28,1.75,0.31,2.17,3.34,4.59,0.06,2.94,4.34,5.4,0.54,0.43,2.74,4.48,1.54,1.72,3.33,4.23,1.27,2.79,1.96,0.27,0.8,0.1,2.26,3.14,1.44,2.01,4.39,4.29,0.9,3.0,4.65,0.42,0.12,1.56,3.73,0.27,1.1,2.91,2.7,3.32,0.86,0.99,3.54,4.53,0.32,1.45,1.82,2.44,0.77,2.64,3.46,1.07,0.7,1.45,0.22,3.55,1.37,2.51,2.96,5.54,1.08,0.66,2.39,5.05,1.33,2.51,0.18,0.18];
        dados_br = linspace(0,2*pi,TAM);
        X = dados_br;
        D = sin(X);
       dados_br = (2.*dados_br - max(dados_br) - min(dados_br))/(max(dados_br)-min(dados_br));
    end
    %%Calculo dos centros e raios
    eucl = [];
    
    Eq = 1000;
    erroQ = [];
    cProx = [];
    while (ger>0)
 	WTA = [];
    count = 0;
    %%Para cada amostra x, calcula-se o neuronio mais proximo e atualiza-se
    %%o seu centro.
    for i=1:length(dados_br)
        eucl = sqrt((dados_br(:,i) - Ci(:,1)).^2)';
        Imenor = find(eucl==min(eucl),1);
        WTA = [WTA Imenor];
        Ci(Imenor,1)= Ci(Imenor,1) - eta*(Ci(Imenor,1) -dados_br(:,i));
        count = count + sqrt((dados_br(:,i) - Ci(Imenor,1)).^2);
    end;
    Eq = count/length(dados_br);
    erroQ = [erroQ Eq];
    count = 0;
    ger=ger-1;
    fprintf('Geração: %.d\n', ger);
    end;
    
    
    figure
    hold on;
    plot(1:length(erroQ),erroQ);
    xlabel('n Geracoes');
    ylabel('Eq');
    %%calculo dos raios baseado nos T centros mais proximos
     T = round(length(Ci)/2)+1;
     for j=1:length(Ci)
         cProx = sort(sqrt((Ci(:,1) - Ci(j,1)).^2));
         
         Ci(j,2) = sum(cProx(1:T,:))/T;
     end;
end;
if(treino2==1)
out=[];

for j=1:length(dados_br)
    mi = (-1)  * (dados_br(:,j) - Ci(:,1)).^2;
    sig = 2*(Ci(:,2).^2);
    e = exp(mi./sig);
    out = [out e];
end;

ger = 1000;
Eav = 1;
vEav = [];
net_o = [];
k=1;
    while Eav > erro && ger > 0
        net_o = [];
        for i = 1:length(dados_br)
            net_o = [net_o W*out(:,i)];
        end;
        
        Y = k*net_o;
        E = D - Y;
        delta_W = eta*out*E';
        W = W + delta_W';
        
        Eav = sum(E.^2)/length(E);
        vEav = [vEav Eav]; 
        ger = ger - 1;
    end;
    
    %plot(1:length(vEav),vEav)
    figure 
    hold off;
    %hold on;
    plot(X, D, '-g', X,Y, '-r');
    xlabel('0º \leq \Theta \leq 360º');
    ylabel('seno(\Theta)');
    legend ('Seno','Rede');
    
    fprintf('treino finalizado %i\n',Eav);
    
    %%Plot das gaussianas
    %%OBs este plot so funciona pra 4 neuronios, não adapta-se automatico
    %%de acordo com o numero de neuronios, deixei assim pq nao tem muitas
    %%cores disponiveis pra plotar cada area de ativaçao com uma cor
    %%distinta.
    
    figure
    hold on;
    xlabel('0º \leq \Theta \leq 360º');
    ylabel('seno(\Theta)');   
    gauss = strings(C,1);
    
    for i = 1:C%imprime gráfico das gaussianas
        %fprintf("%d ", i);
        plot(X, out(i,:),'--');
        gauss(i) = "Gauss. " + i;
        
    end;
    legend(gauss)
    
end;

if(treino1==0 && treino2==0)
    dados_tr = 0:pi/360:2*pi - 2*pi/180; 
    X2=dados_tr;
    %%normalizado
    dados_tr = (2.*dados_tr - max(dados_tr) - min(dados_tr))/(max(dados_tr)-min(dados_tr));
    D2 = sin(X2); %valor dos senos reais dos angulos

        out2=[];
        net_o2 = [];
        for j=1:length(dados_tr)
            mi = (-1)  * (dados_tr(:,j) - Ci(:,1)).^2;
            sig = 2*(Ci(:,2).^2);
            e = exp(mi./sig);
            out2 = [out2 e];
        end;

        for i = 1:length(dados_tr)
                net_o2 = [net_o2 W*out2(:,i)];
        end;

    res = k*net_o2;
    plot(X2, D2, '-g', X2,net_o2, '-.m');
    xlabel('0 \leq \Theta \leq 360');
    ylabel('seno(\Theta)');
end;

